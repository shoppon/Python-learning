import threading

from time import sleep

MESSAGE_CACHE = []


class Producer(threading.Thread):
    def __init__(self, condition, message_count=10):
        super(Producer, self).__init__()
        self.condition = condition
        self.message_count = message_count
        self.interval = 2
        self.cache = []

    def run(self):
        self.condition.acquire()
        self._update_cache()
        self._produce()

    def _produce(self):
        count = 1
        while count <= self.message_count:
            print('Produce message--->%s.' % count)
            self.cache.append(count)
            self.condition.notifyAll()
            sleep(self.interval)
            count += 1

    def _update_cache(self):
        th = threading.Thread(target=self._send_message)
        th.start()
        th.join()

    def _send_message(self):
        while True:
            self.condition.acquire()
            if len(MESSAGE_CACHE) >= 5:
                self.condition.wait()
            else:
                if self.cache:
                    msg = self.cache.pop(0)
                    print('Send message--->%s.' % msg)
                    MESSAGE_CACHE.append(msg)
                    print('Message cache is: %s after sending '
                          'message.' % MESSAGE_CACHE)
                    self.condition.notifyAll()
                else:
                    self.condition.wait()


class Consumer(threading.Thread):
    def __init__(self, condition=None):
        super(Consumer, self).__init__()
        self.condition = condition
        self.interval = 5

    def run(self):
        while True:
            self.condition.acquire()
            if len(MESSAGE_CACHE):
                msg = MESSAGE_CACHE.pop(0)
                print('Consume message--->%s.' % msg)
                print('Message cache is: %s after consuming '
                      'message.' % MESSAGE_CACHE)
                self.condition.notifyAll()
                sleep(self.interval)
            else:
                self.condition.wait(10)


def main():
    condition = threading.Condition()
    producer = Producer(condition)
    producer.start()

    for _ in range(2):
        Consumer(condition).start()


if __name__ == '__main__':
    main()
